#!/usr/bin/env node

/**
 * start by parsing the command-line arguments
 */
let opt = {
    named: {},
    positional: [],
};

for (var i = 2 ; i < process.argv.length ; i++) {
    const arg = process.argv[i];

    if ("--" == arg.substr(0, 2)) {
        if (arg.indexOf("=") >= 0) {
            opt.named[arg.substr(2, arg.indexOf("=")-2)] = arg.substr(1+arg.indexOf("="));

        } else {
            opt.named[arg.substr(2)] = true;

        }

    } else {
        opt.positional.push(arg);

    }
}

const url           = opt.positional.shift();
const responseType  = opt.named.type ?? "domain";
const serverType    = opt.named["server-type"] ?? "vanilla";

import rdapValidator  from "../lib/rdap-validator.js";
import XMLHttpRequest from "xmlhttprequest";

const jsonResultData = {
    testedURL:              url,
    expectedResponseType:   responseType,
    serverType:             serverType,
    results:                [],
};

rdapValidator.setXHR(XMLHttpRequest.XMLHttpRequest);

let lastPath = null;

const cliResultCallback = function(result, message, context, path) {
    const indentString  = "  ";
    const onlyErrors    = opt.named.hasOwnProperty("only-errors");
    const indent        = indentString.repeat(onlyErrors ? 0 : Math.max(0, rdapValidator.path.length-1));

    if (false === result) {
        message = message + " (" + path + ")";

        console.log(indent + "\x1b[1;31m✘\x1b[0m " + message);

        if (context !== undefined) {
            console.log("\n" + indentString + indentString + indent + JSON.stringify(context, null, 2).trimEnd().replaceAll("\n", "\n" + indentString + indentString + indent) + "\n");
        }

    } else if (false === onlyErrors) {
        if (true === result) {
            console.log(indent + "\x1b[1;32m✓\x1b[0m " + message);

        } else {
            console.log(indent + "\x1b[1;33mi\x1b[0m " + message);

        }
    }
};

const jsonResultCallback = function(result, message, context, path) {
    jsonResultData.results.push({
        testPassed: result,
        message: message,
        context: context,
        path: path,
    });
};

if (opt.named.json) {
    rdapValidator.setTestCompleteCallback(function() {

        jsonResultData.errorCount       = jsonResultData.results.filter((r) => false === r.result).length
        jsonResultData.responseHeaders  = rdapValidator.lastTestedResponseHeaders;
        jsonResultData.jsonResponse     = rdapValidator.lastTestedResponse;

        console.log(JSON.stringify(jsonResultData, null, 2));
    });

    rdapValidator.setResultCallback(jsonResultCallback);

} else {
    rdapValidator.setResultCallback(cliResultCallback);

}

function help(x) {
    console.log("Usage: " + process.argv[1] + " [OPTIONS] URL");
    console.log("Options:");

    console.log("  --help               Show this help.");

    console.log("  --only-errors        Only show errors.");

    console.log("  --json               Output result in JSON.");

    console.log("  --type=TYPE          Expected response type, which must be one of:");
    Object.keys(rdapValidator.responseTypes).forEach((t) => console.log(" ".repeat(25) + "- " + t));

    console.log("  --server-type=TYPE   Server type, which must be one of:");
    Object.keys(rdapValidator.serverTypes).forEach((t) => console.log(" ".repeat(25) + "- " + t));

    console.log("");
    console.log("Copyright 2024 Gavin Brown <https://about.rdap.org>.");

    process.exit(x);
}

if (opt.named.hasOwnProperty("help")) {
    help(0);

} else {
    rdapValidator.testURL(
        url,
        responseType,
        serverType,
    );
}
